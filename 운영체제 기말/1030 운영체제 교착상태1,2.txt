1030 운영체제 교착상태1,2 9주차

교착상태 : 프로세스가 전혀 발생할 가능성이 없는 event를 기다리며 block되어 있는 경우(서로가 서로를 막고있음)

* 예 : 데이터베이스 데드락상태 

* 교착상태와 무기한 연기 상태 구분 필요
(교착상태: 100%, 무기한 연기: 운이나쁘면)

* 4가지 필요조건 _발생원인 (모두 만족시 발생)
: (1) 자원에 대한 배타적사용(상호배제해야하는 상황)
(2) 선점불가능 자원(cpu를 뺏아올수 있으면 교착상태안생김)
(3) 프로세스에 대한 자원의 부분 할당(일부 자원을 가지고 있는 상태)
(4) 환형대기

* 해결기법 3가지
(1) 예방 기법 : 발생하지 않게
- 대부분 자원의 심각한 낭비 초래
- 비현실적임
- 구현 : 4가지 필요조건 중 하나를 제거
-> 상호배제를 배제 : 불가능
-> 선점가능하게 지원 : 자원낭비가 매우 심함
-> 자원의 전체 할당(전 동기화파트에서 철학자가 포크 2개를 들수 있을때만 먹게하기)
: 무기한 연기 발생 가능성
-> 환형대기상태 배제(자원에 번호를 매기고 순서대로만 요청할 수 있게 
_마지막 제일 높은 번호가 제일 낮은 번호를 요청불가능해 사이클이 끊어짐) : 자원 낭비


(2) 회피 기법 : 피해가게
- 항상 시스템을 감시, 안전상태 유지
- 자원 요청을 수락한 다음의 안전상태를 검토한 후 자원을 할당

* 안전상태 : 모든 프로세스를 정상 실행~종료시킬수 있는 방법이 1개이상 존재하는 상태
비안전상태 : 교착상태로 전이 가능성이 존재(무조건 교착상태는 아님)

- 예를 들어 자원이 3개 남아있고, 2개를 요청받았는데 
이후에 교착상태 유발 가능성이 있다고 판단되면 할당을 유보함 
- 은행원 알고리즘(대출해줄수 있는 돈이 있어도 신용등을 다 따져보고 대출함)

- Dijkstra's 알고리즘 [교착상태1 21:15]
자원의 type이 1개,
각 프로세스가 자원의 최대 요구량, 현재 할당량 을 선언하고 시작,
추가 요구 가능량을 계산함 ( ex) 최대3개요구, 1개할당상태, 2개추가요구가능)
- 알고리즘 문제 푸는법
1. 존재하는 총 자원 갯수적어놓고
2. 각 프로세스마다 최대 요구량, 현재할당량으로 추가 요구가능량 계산하여 3column인 표로 그리기
3. 총 자원 갯수에서 현재 프로세스들에게 할당된 자원들 빼고 남은 자원 갯수구하기 _계산준비끝
4. 문제 : process A가 1개 추가요구할 경우 -> 표에서 A상태 update하고 총자원갯수 -1
(그 상태에서  A를 포함한 모든 프로세스들이 남은 추가요구량을 모두 요구하는 상황을 가정(안전상태판단을 위해 worst case 가정))
5. 남은 자원 갯수로 그 중 어떤 한 process의 추가요구량을 만족시켜줄 수 있으면 걔한테 먼저 다 주고 시간을 기다리면 처리가 끝나고 그 프로세스에게 할당 된 모든 자원을 반납함(이때 남은 총 자원으로 어떤 단 하나의 process의 추가요구량도 만족시켜줄수 없으면 거절(block))
6. 그 후도 똑같이 총 자원갯수로 추가요구량을 만족시켜줄 수 있는 process가 있으면 걔한테 모두 줘 먼저 처리시키고 그 후도 반복
7. 이렇게 해서 모든 프로세스를 순서대로 실행가능하면 안전상태이므로 승인
[교착상태1 21:15 문제푸는법 참고]

[교착상태2 4:01 문제]
1) process A에게 1개를 주고 난후 상황에 남은 총자원 갯수로 어떤 프로세스의 추가요구량도 만족시켜줄수 없음
따라서 거절(block)
2) process B에게 2개를 주고 난후 상황에 남은 총자원 갯수로 process B의 추가요구량을 만족시킬수 있으므로 B에게 먼저 주고, 처리되어 B가 모두 반납한 후 남은 총자원 갯수로 다음 가능한 process 처리시키고 반복하여 그 순서대로 실행, 승인

- Habermann's 알고리즘
자원의 type이 여러개,
위 Dijkstar's알고리즘에서 총자원갯수를 type마다 따로 두고, 3개의 column들을 각각 마다 type의 갯수만큼 다시 나눠서 똑같은 방식으로
ex) 최대요구량: typeA, typeB, typeC 현재 할당량: typeA, typeB, typeC 추가요구가능량: '', '', ''
이해안되면 [교착상태2 6:02]참고

[교착상태2 09:30 문제]


(3-1) 검출 및 복구 기법중 검출 기법 : 발생시 처리
- 현재 주로 사용
- 자원할당그래프로 표현
- 그래프 단순화 기법
: 주어진 그래프의 모든 에지들이 제거 되는 경우 교착상태 존재X,
교착상태는 blocked에서 일어나므로 unblocked된 프로세스의 인접 에지들을 제거
* unblocked : 여기선 요구한 자원을 모두 할당 받을 수 있는 프로세스를 의미
- 검출 알고리즘
1. unblocked된 프로세스 찾기(프로세스가 요구하는 에지를 따라가서 요구하는 만큼 자원이 남아 있으면 unblocked)
* 자원에서 프로세스로 할당되는 에지가 아니라 프로세스에서부터 나온 에지를 따라가서
1. 임의의 unblocked 프로세스 노드의 인접한 모든 에지 제거
2. 더이상 unblocked 프로세스가 존재하지 않을때까지 1을 반복
3. 최종형태에서 모든 에지가 제거됐다면 교착상태존재X, 에지가 남아있으면 교착상태 존재O
4. [교착상태2 16:00 단순화과정 예시] 이거보면 이해가능

(3-2) 검출 및 복구 기법중 복구 기법
- 방법 1: 교착상태의 프로세스 일부를 강제종료(프로세스를 기준으로)해서 자원을 반납시키게
-> 종료 cost고려(실행시간, 남은시간, 회계비용)
방법 2: 교착상태 해결에 필요한 자원을 할당받고있는 프로세스를 종료(자원을 기준으로)
* 취약점 : 교착상태가 아닌 프로세스도 종료대상이 됨

[교착상태2 22:20 문제]
1. 프로세스 노드, 자원 노드 그리기
2. 에지 연결
* A는 할당상태 에지, B는 요구상태 에지
* 2차원배열에서 i행이 프로세스, j열이 자원
ex) A = 2 1
           1 1
이면  프로세스i[0]은 자원 j[0]에 2개 연결, 자원 j[1]에 1개 연결되는 에지를 그리면 됨
3. 위 검출알고리즘 적용
A : 교착상태 여부:자원이 하나도 안남아있는데 요구하는 자원이 있으니까 둘다 blocked상태이다 그래서 교착상태이다
방법 : 위 복구 기법설명에 방법 1같이 설명

[교착상태2 23:40 문제]
1.- 예방기법, 동시에 4명만 앉게 해서
- 철학자 수를 나타내는 counting semaphore이용
- i가 왼쪽, i+1이 오른쪽
- 철학자가 앉을때 P()연산(lock), 다먹고 일어날때 V()(unlock)
2. - circular wait : 환형대기(위에 메모참고)
- 이해안됨 나오면 그냥 틀릴까
- 그냥 위에 환형대기 해결기법 참고해서 어거지로 외울수있음



* 비안전상태를 보는건 회피기법, 교착상태를 보는건 검출 및 회복기법

질문
[9주차퀴즈 9번]
8번 - P1은 왜 아닌지? 가운데 자원에도 에지가 있었네 ㅅㅂ

9번 - 안전순서가 존재하니까 안전상태아님?
A. 안전상태는 최대요구량 - 현재할당량인 추가요구가능량으로 계산해서 나온것
표에 있는건 현재 요구량임, 현재요구량은 충족가능하므로 교착상태는 아님





