1107 운영체제 주기억장치 관리1

계층구조
CPU레지스터 - CPU Level1캐시 - L2캐시 - 메인메모리 - 하드디스크

블럭 Block : 보조기억장치(하드디스크)와 주기억장치(메인메모리)간 데이터 전송 단위(약 4KB)
워드 Word : 주기억장치와 CPU간 데이터 전송 단위(64bit) _컴터사양할때 32bit, 64bit 그거

메모리의 두가지 관점
- 논리적 주소(공간) : 프로그래머가 프로그래밍시 사용하는 공간
- 물리적 주소(공간) : 실제 자료나 프로그램이 저장되는 공
ex) 게임할때 모든 data를 메모리에 올려놓고 사용하진 않음 지금 쓰는 부분만 올려놓음

메모리사상(바인딩binding) : cpu가 data의 논리적 주소를 요청하면 중간에 물리적주소(하드웨어의 실제주소)로 변환하여 보내짐
_논리적 주소와 물리적 주소의 연결
=> 메모리관리장치(MMU)로 실행
ex) 논리적으로 0번지에서 n번지중 336번지요청 -> 실제 주소인 14000번지를 더해서 14336번지로

* 운영체제가 발달할수록 바인딩 시간을 늦춤
바인딩방식에따라
- 컴파일시간 바인딩(compile time), 적재시간 바인딩(load time), 수행시간 바인딩(run time)


주기억장치 구성 정책
- 1) 동시에 메모리에 적재가능한 프로세스의 수(multiprogramming degree)
- 2) 적재된 프로세스들에게 메모리를 똑같이 나눠줄건지 다르게 나눠줄건지
- 3) 각 프로세스에 할당되는 메모리크기를 미리 정해놓을건지(고정분할&정적분할 / 가변분할&동적분할)

*
연속메모리 : 한 프로그램전체가 메모리주소 순서대로 올라와있어야함

연속 메모리 할당 발전과정
단일프로그래밍시스템 Uniprogramming (데이터 전체를 한번에 적재) 
-> 고정분할다중프로그래밍 FPM (고정분할) 
-> 가변분할다중프로그래밍 VPM (가변분할)


단일프로그래밍시스템 Uniprogramming 
- 메모리에 프로세스 한 개만 올라옴
- 메모리내에 프로세스가 올라오는 주소와 크기가 고정됨
- 따라서 컴파일시 바인딩 
- 문제점
1) 프로그램 크기가 주기억장치의 가용공간보다 클 경우
- 중첩구조로 해결(나눠서 2번 또는 여러번에 걸쳐 읽음)
2) 메모리에 올라온 프로세스가 자꾸 kernel의 영역(주소)를 침범함
- 경계 레지스터(boundary register) 사용
3) 메모리 낭비(고정되어있는 프로세스부분,kernel부분외 남는부분), 
성능저하(메모리에 프로세스1개만 올라오므로)
- 다중 프로그래밍 기법 사용(메모리에 여러프로세스 올려놓기)


고정분할 다중프로그래밍 FPM (Fixed Partition Multiprogramming) 
- 메모리에 프로세스가 여러개 올라옴(주기억장치 공간을 미리 분할  _kernel외의 공간들이 partition됨)
- 메모리내에 프로세스가 올라오는 주소들과 크기가 고정됨
- partition된 각 영역에는 하나의 프로그램만 적재가능(k개로 분할시 k개만 적재가능 _multiprogramming degree = k)
- partition된 영역의 크기기가 다 다른데 프로세스가 적재될때 자신의 크기에 맞춰서 load시에 바인딩(load time binding)
- 문제점
1) 프로그램 크기가 주기억장치의 가용공간보다 클 경우
- 중첩구조
2) 프로세스들이 kernel이나 서로의 영역을 침범함
- (patition들 사이에)여러 개의 경계레지스터
3) 각 분할 영역마다 메모리 낭비되는 부분(내부단편화)
4) 서로 다른 영역들의 남은 공간의 총합으로 보면 충분하지만 나눠져있으므로 한프로그램이 못올라감(외부단편화)


