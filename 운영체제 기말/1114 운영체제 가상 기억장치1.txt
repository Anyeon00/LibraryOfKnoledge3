1114 운영체제 가상 기억장치1

가상기억장치
- 프로그램 전체가 아닌 '필요한 블록만 비연속적으로(비어있는 여기저기에) 메모리에 적재
- swap out이 자주 일어나므로 address mapping을 효율적으로 할 필요
* address mapping : virtual memory에서 main memory로 옮길때 논리적주소를 물리적주소로 조정해주는 것(주기억장치 관리1의 메모리사상 참고)
- runtime biniding
- 기법
1. 페이징 시스템 : 똑같은 크기의 블록(분할된 메모리영역)으로 분할
2. 세그먼테이션 시스템 : 서로 다른 크기의 논리적인 단위로 분할

* 블럭 사상
- 내가 원하는 블럭의 메모리 시작주소를 runtime에 찾아내는것
- 가상주소를 블럭 사상테이블을 이용하여 실제주소로 사상

- 가상 주소 (b, d) :
b _블럭번호(논리적 주소)
d _그 블럭안에서의 상대주소(변위)

- 블럭 사상 테이블 block map table(PMT) 구조 :
블럭번호 _구조체배열 index번호
존재비트 _주기억장치에 적재 여부
실주소 _적재된 주기억장치 주소(물리적 주소)(displacement)

- 블럭사상 과정 [11주차 가상 기억장치1 9:20]
1. 가상주소의 블록번호를 보고 PMT을 찾아감
2. 존재비트가 1인지(주기억장치 적재 여부) 확인
2-1. 0일시 mapping전에 먼저 메모리에 적재해야함 (아니면 페이징시스템에서 page fault로 block됨)
3. PMT의 실주소를 가져옴 
4. 실주소에 가상주소에 있는 상대주소를 더함


페이징 시스템
- 똑같은 크기의 블록으로 분할
- 블록단위로 할당할 건데 다 똑같은 크기로 쪼개놓음
- 그래서 매핑이 간단한게 장점
- 블록 대신 페이지라는 용어 사용 _페이지는 실행하는 프로그램, 페이지프레임은 메모리의 저장공간
- 용어:
페이지번호 : 블록번호
페이지 프레임 번호 : 실주소(쪼개진 영역)
* 페이지와 페이지프레임의 크기가 같음(올릴 프로그램 블럭크기와 쪼개진 저장공간들의크기가 모두 같음)
* 페이지프레임의 크기가 다 똑같으므로 페이지크기가 1000이면 페이지프레임1은 1000, 페이지프레임넘버2는 2000이런식임

- 매핑(주소사상)
: 기본적으로 블럭사상 이용 
단, 페이징시스템에서는 실주소 대신 페이지프레임number 사용
(페이지프레임크기는 다 똑같으므로 실주소위치를 직접 쓰기보다 number를 매겨 관리)

- 매핑 기법 3가지: 직접사상, 연관사상, 혼합사상


직접사상
- ex)
블럭사상과정에서 실주소 대신 페이지프레임number사용하는것 외에 똑같음
[11주차 가상 기억장치1 19:23]

대략적인 설명: 
- 0001, 0101, 1001, 1101
- 앞 두자리는 다른데, 뒤 두자리는 같음
- 앞 두자리는 순서대로 0, 1, 2, 3이고 뒤의 주소는 1임
- 즉, 앞 두자리는 논리적주소(블록번호)이고 뒤 두자리는 가상주소의 블록내 상대주소임
- 블록번호를 따라가 PMT의 실주소를 가져와서 논리적주소(블록번호)인 앞두자리와 바꿔주면 사상끝(뒤 두자리는 그대로)
=> 뒤 두자리인 가상주소의 블록내 상대주소는 그대로, 블록번호인 앞두자리를 PMT의 실주소로 바꿔주면 사상 끝
[11주차 가상 기억장치1 19:43]


- 단점 : PMT가 memory에 있음, mapping시 마다 memory의 PMT를 사용함
-> 성능저하 초래, PMT size
- 해결 : 연관사상기법




퀴즈및 기말 문제
*
1K = 2의10승
페이지크기가 4KB 면 2의 12승 -> displacement(변위)는 뒤에서 12자리까지
메인메모리크기가 64K면 페이지크기로 나누면 페이지프레임개수는 64개, 
페이지번호가 6bit면 PMT의 엔트리최대갯수는 6bit로 나타낼수있는 최대값인 32개

* entry : PTM같은 테이블(2차원배열)에서 해당 index번째 행에 있는 정보

* 기말고사나 퀴즈에는 1K로 출제

[11주차 가상 기억장치2 5:40 예제] - 젤위에가 index 0번임
[11주차 가상 기억장치2 7:50 예제] - 3) 가상주소는 모든 페이지프레임을 다 안쓸수도 있으므로 full bit수보다 적을수도 있지만, 실주소이므로 bit수 full로 명시(페이지프레임수7bit(2의15승 / 2의8승) + 페이지크기8bit = 총 15bit로)
[11주차 가상 기억장치2 7:55 예제] -1) 가상기억장치는 실제 메모리보다 큰 프로그램도 올릴수 있으므로 페이지개수bit를(PTM의 entry를) 실제메모리크기보다 많이 쓸수도있음
[11주차 가상 기억장치2 8:00 예제] 9-1) 페이지 개수는 실행하는 프로그램의 블록을, 페이지프레임 개수는 메모리의 블록을 말함
: Q. 페이지크기가 1K인 가상메모리 시스템, 가상주소 : 0101 0101110010
1) 몇번페이지인가? (0101이므로 5)
2) 변위는? 0101110010 (위 설명의 이진수의 뒷자리부분 _바꾸는건 앞자리인 블록번호를 PMT의 실주소로)


[대면 퀴즈]
q. 총 페이지 프레임의 크기?
a. 페이지크기 1K, 주기억장치 크기는 16K면 답은 페이지갯수x한 페이지해서 16K아님?
-> 페이지프레임크기 = 페이지크기 이므로 답 1K
(페이지프레임크기가 페이지프레임 하나의 크기를 말한거엿음)










