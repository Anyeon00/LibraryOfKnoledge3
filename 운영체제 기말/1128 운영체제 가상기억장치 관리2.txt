1128 운영체제 가상기억장치 관리2

고정 할당 기반의 교체 기법 이어서..

FIFO 알고리즘
- fault 발생시에 먼저 주기억장치에 적재된 페이지부터 교체(메모리에 적재된 순서대로)
- 페이지들의 주기억장치 적재시간을 기록해야함
* 문제풀기 _fault발생시, queue 젤 앞에잇는 페이지번호를 현재 가지고 있는 메모리에서 빼고 넣기
ex) 213을 가지고 잇고 5를 받아야하는데, queue 젤앞에가 2면 213에서 2빼고 5넣기

LRU 알고리즘 (Least Recently Used)
- 가장 오랫동안 참조(접근)되지 않은 페이지와 교체
- 매번 참조시간을 기록해야 함(오버헤드)
- 어떤 페이지에 참조할때 그 페이지의 참조시간을 update해줘야함 _오버헤드 발생
- 실제로 가장 많이 사용
* 문제풀기 _현재시점으로부터 사용한 시점이 제일 먼 페이지 삭제

LFU 알고리즘 (Least Frequently Used)
- 가장 참조횟수가 적은 페이지와 교체
- 페이지에 참조할때 마다 참조횟수를 기록해야함

NUR 알고리즘 (Not Used Recently)
- 최근에 사용되지 않은 걸 적당히 선택해서 교체하자
- 참조 비트 사용(가상기억장치 관리1 참고) - 가장 최근에 reset한 이후에 참조했냐 아니냐
- 갱신 비트 사용(") - 최근에 data가 update됐냐 아니냐
- 참조비트가 0인걸 먼저 고르고, 그다음으로 갱신비트가 0인걸 _최근 참조안된거중에 갱신안된거 골라서 교체 
// 갱신된거를 교체하려면 갱신내용을 디스크에 써줘야하는데 오버헤드생김

[13주차 가상 기억장치 관리2 15:25]

Second chance 알고리즘
- 기본적으로 FIFO 알고리즘
- 참조비트 사용
- 이때 교체하려는 페이지의 참조비트가 0이면 교체 실행, 1이면 교체하지 않고 0으로 바꾸고 큐의 rear에 재삽입, 그리고 FIFO Queue에서 그다음 페이지에 대해서 알고리즘 진행
- 참조비트를 주기적으로 reset하지 않음
- 새로 들어온 페이지의 참조비트는 당연히 참조했으므로 1로 Queue의 rear에 삽입됨
- 실제로 사용함

[13주차 가상 기억장치 관리2 18:15]

클럭Clock 알고리즘
- 참조비트 사용
- Second chance 알고리즘에 원형 큐를 사용한 기법 _queue의 맨마지막이 처음을 가리킴
-> 원형큐가 아닌 경우는 앞에걸 삭제하고 rear에다가 다시 삽입해야함
-> 원형큐로 만들면 참조비트만 (0으로)바꿔주고 front를 가리키는 포인터를 뒤로 한칸 옮겨주면 똑같은 효과(앞에 삭제된게 맨뒤에 삽입됨)
- 교체해야할 시 포인터가 가리키고 있던 front의 페이지를 메모리서 삭제후 그자리에 새 페이지 추가후(참조비트1로) 포인터 뒤로 한칸 옮김

Second chance 개선 알고리즘
- 참조비트와 갱신비트가 0 0 이면 교체
- 1 0 이거나 0 1 이면 0 0 으로 만들고 Queue 맨 뒤에 삽입
- 1 1 이면 0 1로 설정하고 Queue 맨 뒤에 삽입
- 실제로 사용함





