1128 운영체제 가상기억장치 관리3

가변할당 기반(에서)의 교체 기법
* 가변할당 : 각 프로세스에게 실행해가며 필요에따라 더 많이 할당해주거나 적게 해주거나

Working set 기법
- Working set : delta기간동안 참조한 페이지의 집합 _즉 최근 일정 시간동안 참조한 페이지들의 집합
- 프로세스의 working set은 시간이 지남에 따라 바뀜
*지역성 기반 // 가상 기억장치관리1 지역성 참고
- 기법 : Working set에 포함된 것을 주기억장치에 적재(즉 최근에 참조한걸 모두 적재)
- Working set 크기만큼 할당해줌(working set에 있는 페이지 갯수?만큼 할당하므로 가변할당)

ex) 13주차 가상기억장치관리3 3:50
-> 윈도우size가 3이므로 최근 접근 페이지3개만 working set에 있도록 계~속 변경(fault가 아닌데도 working set에 있는 것만 메모리에 있도록 계속 교체/삭제/삽입)
-> 새로운 페이지가 들어오는게 fault가 발생한 시점
-> 매 시점 working set에 있는 페이지 갯수들을 시점들 갯수로 나누면 working set즉, 할당한 페이지프레임 갯수의 평균
* 즉 현재 시점 기준으로 윈도우size만큼 앞에까지의 페이지를 working set에 넣고, fault시점이랑 상관없이 모든 시점에서 실행

- 특성 : 추가로 적재되는 페이지가 없어도 교체되는 페이지가 있을수 있다(working set대로 최근 참조한 페이지 n개만 유지해야함에 따라 교체)
- 단점 : 페이지를 참조할 때 마다 working set을 조정해야하는 오버헤드 발생
=> fault발생 여부와 관계없이 관리됨

[문제 13주차 가상기억장치관리3 8:00] 
Q.
1) 교체대상 : working set에 포함되지 않는 페이지들
2) 각 프로세스에게 할당해주는 memory 양 : working set의 크기만큼
3) fetch 시기 : fault가 발생했을때



PPF 기법 (Page Fault Frequency)
- Working set은 계~속 바꿔줘야하니까 PPF에서는 페이지 fault가 발생했을때만 바꿔주자
- 페이지 부재율 : fault 발생 간격 _넓으면 메모리 할당을 줄임, 짧으면 메모리 추가로 할당
-> 임계값 t 보다 간격이 크면 부재율이 높다고 판단, 짧으면 낮다고 판단
- 기법 :
-> fault 발생시 그 시간을 기억
-> 현재 fault 발생시각 - 직전 fault발생시각 = IFT(fault 발생 간격)
-> IFT가 임계값 t보다 큰지 작은지 판단
-> IFT(fault 발생 간격) > t(정해놓은 임계값)이면 지난번 fault이후로 실제로 참조한 페이지만 남김
-> IFT <= t 면 메모리가 모자라는거니까, fault된 페이지를 추가
ex) 13주차 가상기억장치관리3 11:11
fault와 fault사이 간격이 2 -> 임계값t가 2인데 같거나 작다에 해당하므로 새로들어온(fault된) 페이지를 추가
그다음 fault와의 간격은 1 -> 마찬가지로 같거나 작다에 해당하므로 추가
그다음 fault와의 간격은 2 -> 위와 마찬가지
그다음 fault와의 간격은 3 -> 임계값 t보다 크므로 fault와 fault사이에 참조한 페이지 + 새로 들어온 페이지만 남기고 나머지 다 삭제(앞에 fault시점 페이지도 같이남김)
페이지 부재 발생횟수, 평균 주기억장치 할당량 영상 참고
=> 페이지폴트발생시 폴트와 폴트 사이 간격이 임계값이하면 계속추가, 이상 범위면 그 사이것들만 남기고 제거


VWIN 알고리즘 (Variable MIN)
- 실현 불가능
- 미래에 참조될 페이지를 미리 알고 미래에 참조하지 않는 페이지는 교체시켜버림
ex) 13주차 가상기억장치관리3 14:00
윈도우크기가 3, 페이지 fault 발생기점으로 향후 3개까지 보고 그사이에 쓰이면 메모리에 올리고 남겨둠,
향후 3개안에 안쓰이면 fault발생시점에만 쓰고 바로 다시 삭제
=> 폴트시 뒤에걸 봄, 윈도우크기안에 쓰이면 남겨놓고 안쓰이면 올렷다가바로삭제


* 윈도우크기 결정 공식
: d = R(fault를 처리하는데 드는 비용)/U(메모리를 유지하는 비용)

* 페이징 시스템의 페이지 크기 결정
- 작게 하는 경우 : 필요한부분만 적재됨, 내부 단편화 줄음 / 페이지 갯수&PMT가 커지므로 관리 오버헤드 증가
- 크게 하는 경우 : 

* 프로그램 구조 재구성 Program Restructure


[퀴즈 13주차 가상기억장치관리3 22:50]
-> A는 fault발생시 block되서 대기하는동안 메모리를 계속사용함, B는  중간에 block도 안되고 빨리 작업을 마침 _ 메모리 점유시간

[퀴즈 13주차 가상기억장치관리3 24:50]
3) window size가 5이므로 앞에 5개에 있는게 working set에 들어가 있음 근데 왜 답이..?

[퀴즈 13주차 가상기억장치관리3 24:55]

[퀴즈 13주차 가상기억장치관리3 25:00]


* 문제풀떄 젤 처음에 메모리에 올라가는 프로그램들도 fault로 쳐서 계산

질문 13주차 가장기억장치관리3 24:50 3번, window size 5개이므로 앞으로 5개는 22121인데 왜 답은 123?
-> 시점 2 부분이 뒤로 밀린거, 1을 가리키는 거라 치고 풀기
