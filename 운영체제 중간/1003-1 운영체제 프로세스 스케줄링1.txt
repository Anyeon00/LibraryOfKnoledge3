1003-1 운영체제 프로세스 스케줄링1		5주차

스케줄링: 다음에 running할 프로세스를 결정하는 것

- 목적: 시스템 성능 향상
*대표적 성능지표: 응답시간, 작업처리량, 자원활용도
*기타 성능지표: 공평성, 예측성(어떤 프로세스의 작업시간이 오래걸릴지 금방 끝날지 판단해 스케줄링),
 무기한 연기 방지(에이징 기법 사용_여태까지 기다린 시간을 반영해 우선순위를 상향시켜줌)


-스케줄링 고려항목
-> 처리시간 
: 일반적으로 처리시간 짧은 프로세스가 우선권을 줌 
(입출력위주(I/O-bound)가 연산위주(compute-bound)보다 짧아서 우선순위가 높음)(5주차 스케줄링 1 - 4:20초)
-> 시스템 속성
: 일괄 처리 시스템(batch) 대화형 시스템(시분할)
(batch는 여러개의 작업들이 모두 끝나야 cpu반환하므로 더 느림)
-> 빠른 응답이 중요한 경우(실시간)


-스케줄링 단계
-> 단기(Short-term) : ready에서 running으로 갈때
-> 중기(Medium-term) : suspended에서 active 상태로 갈때
-> 장기(Long-term) : created될때


- 스케줄링 정책
-> 선점/비선점 정책

==>선점 스케줄링 (preemtion)
: 우선순위로 인해 실행중인 프로세스를 중지가능한 스케줄링,
 지가 반납하는게 아니라 커널이 cpu를 뺏어감,
 시분할, 실시간 시스템에 적합(clock사이 interrupt로 중지가능),
 프로세스교환마다 매번 문맥교환필요로 느려짐

==> 비선점 스케줄링 (preemption불가능)(blocked불가능)
: 실행중인 프로세스를 중지 불가능한 스케줄링,
 지가 반납할때 까지는 계속 쓸수있음,
 프로세스 종료시간 예측가능/ 평균 응답시간이 길어짐, 우선순위 반영이 안될수도



우선순위 

-부여방법
-> 정적 우선 순위 : 프로세스 생성시 부여되고, 실행중 불변 / 변화에 대응 곤란
-> 동적 우선 순위 : 시스템&프로세스 상태 변화에 따라 우선순위 변경, 유연한 대응 가능 / 매번 우선순위 변경
-> 매입 우선 순위


스케줄링 기본 알고리즘 5가지

1. FIFO 스케줄링 (=FCFS first come first served)
- Queue 사용
- 비선점 스케줄링(nonpreemptive scheduling)
- 일괄 처리 시스템(자원의 효율성 높음)
- 대화형 시스템(시분할)에 부적합
- 장시간 독접하는 경우 평균 응답시간 느려짐
- 스케줄링 기법으로 적합치 않음

* 그리기 (5주차 프로세스 스케줄링 1 - 12:30초)
- 도착한 순서대로 프로세스 번호 1, 2, 3, 4, 5,... 위에다 표시, 밑에다 진행기간끝에 프로세스 번호 표시
=> 평균대기시간, 평균응답시간(대기+서비스시간), 서비스순서(nonpreemtive라 무조건 순서대로 12345..)
=> 평균응답시간: 평균대기+평균서비스시간 이렇게 구하기

2. RR(Round-Robin) 스케줄링
- Queue 사용
- 선점 스케줄링(preemtive scheduling)
- 각 프로세스에 시간할당량 부여
- 한 프로세스가 cpu독점하는걸 방지	V
- 대화형(시분할) 시스템에 적합

*그리기 (프로세스 스케줄링 1 - 14:50) 
=> ex) 프로세스당 시간할당량이 2라면
1번 프로세스를 queue에 넣음
1번 프로세스가 시간할당량2만큼 쓰고 남은 서비스시간을 가지고 queue의 뒤로 다시 들어감,
언제든지 새로운 프로세스가 도착하면 바로 queue의 제일 뒤로 들어감
반복
* 시간할당량이 끝난 프로세스와 지금 도착한 프로세스의 타이밍이 같으면 도착한 프로세스가 먼저 들어감
=> 평균반환(응답)시간: 들어온 시간~모두마치고 떠난 시간 평균
=> 평균 대기시간: 기다린시간(실행되지않고 다른 프로세스 돌아가는동안 기다린시간 다 더하기) 평균

3. SPN(Shortest-Process-Next) 스케줄링 (=SJF_Shortest Job First scheduling)
- 실행시간(burst time)이 가장 짧은 프로세스부터 스케줄링
- 비선점 스케줄링(nonpreemtive scheduling)
- 장점: 평균 대기시간 감소, 빠른 응답시간 제공, 큐의 크기 감소	V
- 가장 좋은 스케줄링 알고리즘
- 단점: 무기한 연기 발생가능, 실행시간에 대한 정확한 예측은 사실 아무도 할수 없음

*그리기
ex) 가장 먼저 도착한 1번 프로세스부터 실행,
1번 프로세스가 끝난 시점에 받은 프로세스중 실행시간이 더 짧은 프로세스를 먼저 실행(도착순서상관x)
반복

4. SRTN(Shortest-Remaining-Time-Next) 스케줄링 (=SRT)
- 위 SPN을 preemptive 방식으로 만든것
- 단점: 실행시간 예측을 최초 뿐만아니라 잔여 실행시간에 대한 계산도 계속 필요, 문맥교환필요

* 그리기 2번RR스케줄링과 3번SPN스케줄링 합친 방법(실행시간을 잔여시간으로 계산)
* Queue에 잔여시간 같은 프로세스가 2개이상이면 먼저 온거부터 처리
* Time quantum이 항상 1임

5. HRRN(High-Response-Ratio-Next) 스케줄링
- 응답률 = (대기시간+서비스시간)/서비스시간
=> 서비스시간이 길어질수록 응답률낮아짐, 대기시간이 길어질수록 응답률이 높아짐
=> 장시간 대기 방지
- 비선점방식

*그리기
ex) 위 식에 응답률 계산해서 높은것부터 스케줄링

=> 요약:
1. FIFO = 비선점, 무조건 들어온 순서대로 처리
2. Round Robin = 선점(preemption)이지만 우선순위는 없음(시간할당량채우고 큐뒤로)
3. SPN = 우선순위있는데 비선점(처음에 우선순위정한대로 하나씩 완전히 처리)
4. SRTN = 우선순위도있고 선점(시간할당량끝날때마다 우선순위를 정해서 큐뒤로)
5. HRRN = 장시간대기방지(에이징기법)

=> 모두 시작하기전에 실행시간을 예측하기 쉽지않음







7주차플립 스케줄링 문제풀이 영상