1009-1 운영체제 프로세스 동기화1

프로세스 동기화
-> 여러프로세스가 독립적으로 존재하며 움직임
-> 공유하는 데이터에 접근시 문제 발생 ***
=> 커널이 해결해야 함

비동기 병행 프로세스
- 비동기적 : 각 프로세스들이 서로 진행 상태를 모름
- 병행성 :  다수의 프로세스가 동시 존재
* (병행성: 여러 프로세스가 프로세서를 번갈아 사용
   병렬성: 프로세서가 여러개 존재, 여러 프로세스를 동시 실행 가능)
- 병행중인 프로세스들이 공유 데이터에 동시 접근시 문제 발생
=> 해결방법 _상호 배제 

상호 배제 기법
- 프로세스들의 임계지역 동시 진입을 금지시킴(한번에 하나만)
* (임계지역 : 공유 데이터에 접근하는 코드 부분)
ex) 프로세스1이 코드를 임계구역에서 실행중인데 preemption이 일어나 프로세스2가 임계구역에 들어오려 할때 막아줌
- 상호배제 프리미티브
=> enterCS()프리미티브 : 안에 다른 프로세스가 있는지 검사, 들어가기전에 알림
=> exitCS()프리미티브 : 나오고나서 알림
* CS(Critical Section)
- 상호배제 프리미티브 조건
1. 상호배제 : 한 프로세스가 자신의 CS를(임계지역에서) 실행중이면 다른 프로세스는 CS를 실행하면 안됨
2. Progress(no excessive blocking) : CS를 수행중이지 않은 프로세스가 다른 프로세스의 CS수행을 제어/간섭하면 안됨(화장실에서 나왔는데 다른 프로세스가 못들어가게 잠가놓을수 없음)
3. 무기한 연기/제한된 대기(Bounded waiting) : 한 프로세스가 임계구역 진입 요청 후부터 요청의 수락까지 기간내에, 다른 프로세스가 수행하는 횟수에 제한이 있어야함(무기한 연기되지않고 일정시간 지나면 들어갈수있게 보장)

상호배제프리미티브 구현
방법1 : 프로세스 p0, p1 / turn변수가 0이면 p0실행, 1이면 p1실행 / 끝나고 변수 넘겨줌
p0 : while(turn == 0){ //p0실행} turn = 1;
p1 : while(turn == 1){ //p1실행} turn = 0;
- 문제 : 내 프로세스를 다시 실행하려면 상대 프로세스로 가야 다시 실행가능하므로 연속으로 실행 불가능
(Progress 조건 불만족)

방법2 : 각 프로세스에 해당하는 flag변수를 둠 / 진입할때 자신의 flag를 1로 나오면 0으로 
/ 진입전 상대 flag 확인후 진입 (확인하고 flag 1로 바꾸고 진입)
flag[0] = 0;
flag[1] = 1;
- 문제 : 들어가려고 상대flag확인했는데 0임, 그래서 들어가기전 내 flag를 1로 바꾸려는데 그전에 문맥교환일어남, 상대가 임계구역에 들어옴, 그리고 문맥교환이 일어나서 다시 내 flag를 1로 마저 바꾸고 임계구역에 들어가서 임계구역에 같이 존재(상호배제 조건 불만족)

방법3 : 방법2는 상대flag 검사 후 내 flag 바꿈, 방법3는 반대로 내 flag 바꾸고 상대 flag확인
- 문제 : 1로 바꾸고 문맥교환일어남 -> 상대도 1로 바꿨는데 내 flag때문에 못들어감 -> 다시 문맥교환 일어나도 나도 상대 flag떄문에 못들어감 -> 무한루프(상호배제는 확실하지만, Progress 조건 불만족)





