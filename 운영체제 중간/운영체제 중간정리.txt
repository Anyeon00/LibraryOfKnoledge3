프로세스 상태전이도+ 구체적사례
1) running -> ready
- 할당된 time quantum을 다씀, 우선순위가 더 높은 프로세스에게 cpu를 preemption당할때
2) running ->blocked(asleep)
- 입출력을 만났는데 data가 준비되지 않았을때, 공유데이터에 접근해야하는데 lock이 걸려있을때
3) running -> suspended ready
- 프로세스가 많이 생성됐는데 실행중인 프로세스의 우선순위가 낮을때, 프로그램실행결과에 이상이 생겨 ctrl+z로 중단할때
4) running -> terminated
- 실행중인 작업을 완료했을때, ctrl+c로 종료시켰을때
5) blocked -> ready
- 어떤 프로세스에서 시그널을 기다리고 있는데 시그널이 도착했을 때
6) ready -> suspended
- 프로세스가 많이 생성되어 메모리가 모자랄때 우선순위가 낮아 suspend됨

==================
처리율 throughput: 단위시간당 처리능력
신뢰도 reliability: 고장이 잘안났으면 좋겠다
반환시간/응답시간 ~time: 작업 처리시간
가용성 availability: 쓰고자할때 바로 쓸수 있는지

커널의 주 기능
1. 자원 관리-하드웨어자원(메모리등) & 소프트웨어자원(file등)
2. 입출력 관리 - 커널안의 buffer를 이용함(프로그램과 입출력장치 사이에서 buffer를 거침)

--------------------------
'디스크'개념 등장spooling (버퍼 역할)(미리 읽어놨다가 cpu로)
'다중프로그래밍'multi programming(디스크에 여러 작업을 동시에 load할 수 있음)
=> 한 작업이 끝나도 idle타임동안 놀지 말고 바로 다른 작업 시작가능
-다중모드(하나의 컴퓨터로 batch,time-sharing,real-time 다 수행)
병렬처리 시스템 환경 
- cpu가 여러개 존재(Multi-processor)
- 처리율, 신뢰성 향상
- 강결합시스템(cpu들이 메모리 공유) (_Tightly Coupled)
분산 시스템 
- 별도의 컴퓨터가 net-work로 연결됨 (분리된 기기가 하나의 os처럼)
- 약결합시스템(메모리 공유x) (_LooselyCoupled)
-----------------------------
scheduling은 ready를 대상으로 함
PCB: 프로세스 개당 1개의 pcb필요
- 프로세스id, 우선순위, 현재상태, 메모리관리정보, 문맥저장영역
 suspended
- 기억장치를 잃은 상태
- 프로세스/기억장치의 양이 많아져 느려졌을때 우선순위가 낮은건 잠깐 디스크로 내보냄
----------------------------
프로그램된 제어 IO: cpu가 직접 IO장치제어 (busy wating 입력확인반복)
인터럽트 제어 IO: block시킴
DMA: cpu없이 IO전담프로세서
----------------------
Thread 공유자원: code, data, file
따로 : Thread ID, Stack, Program Counter, register set(문맥교환관련)
이점
- 응답성 : 한 스레드가 blocked되더라도 다른 스레드는 작업가능
- 자원공유 : 위의 설명대로 한프로세스내에서 자원을 공유함
- 경제성 : 자원공유와 마찬가지로 자식프로세스를 만드는 것보다 경제성이 좋음
총 스레드 갯수: 생성된 스레드 n개 + 메인스레드 1개
문맥교환시 중요한 문맥
: 시스템 수준 문맥 - cpu내의 각종 범용 특수 레지스터의 내용(Program counter resister, Stack Pointer등)
'모든 쓰레드에 메인(main)함수가 있다'는 틀림
-----------------------------
fork() : 유닉스의 system call
- 프로세스 수를 증가시키는 유일한 방법
- 프로세스 id제외 모든걸 상속
- 작업상태도 copy됨
exec() : fork()로 새로운 프로세스 생성후, 원하는 프로그램으로 변경
---------------------------------------
스케줄링 - 대표적 성능지표: 응답시간, 작업처리량, 자원활용도
에이징 : 스케줄링시 대기시간 고려해주는것

직접 스케줄링하기
평균대기시간,평균응답시간
FIFO(FCFS), RR, SPN(SFJ), SRTN(SRT), HRRN  // 퀴즈풀어보기
MFQ				// 5주차 스케줄링2 18:40 풀어보기

Q. 다단계 피드백 큐(MFQ) 스케줄링 기법에서 다음 사항을 어떤 식으로 구현하고 있는 지 설명하시오.
1) 짧은 burst time을 사용한 프로세스에게 우선권을 높여준다.
2) burst time을 많이 사용한 프로세스의 우선권을 낮춘다.
3) 우선순위가 낮은 프로세스의 무한대기가 발생하지 않도록 한다.
4) 프로세스가 처음 시작할 때의 우선순위를 다르게 배정한다.
A.
1) 프로세스가 running후 시간할당량안에 끝나서 timerrunningout되지 않고 blocked되면 상위에 있는 queue에 넣어줌
2) 프로세스가 running후에 timerrunningout되면 우선순위가 낮은 젤 아래에 있는 queue에 넣는다.
3) 각 queue에 대기시간을 정해주고 대기시간이 지나면 해당 queue의 우선순위를 올려준다.
4) 처음에 우선순위가 높은 프로세스는 위에서 시작하게 낮은애들은 아래에서 시작하게 한다.
--------------------------------------------------------------
Q. 다음 각각의 개념들으 그 차이점 위주로 비교 설명하시오. 
1) 시분할 시스템, 일괄처리 시스템
2) 다중 프로그래밍, 다중 프로세싱
3) 강결합시스템, 약결합시스템
4) 다중 프로세스, 다중 쓰레드
5) 선점 스케줄링, 비선점 스케줄링
A.
1) 대화식&응답시간이 중요한 환경, 전체가 묶여서 한번에 처리하는 환경
2) 다중 프로그래밍은 메모리에 여러 프로그램이 실행중에 있는 환경,
 다중 프로세싱은 하드웨어적으로 프로세스가 여러개있어서 병렬처리하는 환경
3) 다중 프로세싱에서 강결합은 프로세서들이 메모리와 clock을 공유하고, 
약결합은 프로세서들이 메모리와 clock을 따로 갖고있지만 네트워크로 연결되어 협력하는 방식의 시스템
4) 다중 프로세스는 서로 독립적인 메모리를 갖는 개체로 구현하는거고
 다중 쓰레드는 하나의 프로세스 안에 속한 여러개체들을 따로따로 스케줄해서 동시에 실행하게 하는 환경, 메모리도 공유
5) running상태의 프로세스를 다른 프로세스나 커널이 cpu를 뺏어올수 있느냐 없느냐
-------------------------------------------------------------
상호배제 프리미티브 조건
1. 상호배제 : 한 프로세스가 자신의 CS를(임계지역에서) 실행중이면 다른 프로세스는 CS를 실행하면 안됨
2. Progress(no excessive blocking) : CS를 수행중이지 않은 프로세스가 다른 프로세스의 CS수행을 제어/간섭하면 안됨(화장실에서 나왔는데 다른 프로세스가 못들어가게 잠가놓을수 없음)
3. 무기한 연기/제한된 대기(Bounded waiting) : 한 프로세스가 임계구역 진입 요청 후부터 요청의 수락까지 기간내에, 다른 프로세스가 수행하는 횟수에 제한이 있어야함(무기한 연기되지않고 일정시간 지나면 들어갈수있게 보장)
Dekker알고리즘	6주차 동기화2 5:50 문제
Peterson알고리즘
하드웨어적 상호배제 해결법- TS() 명령어 (인터럽트받지않음_문맥교환X)
세머퍼기법
- busywating하지않고 block시킴
- P() V()연산  7주차 프로세스 동기화3영상 - 8:40 문제(counting semaphor의 경우)
메모장 운영체제 동기화3파트 (플립영상 문제4개)





